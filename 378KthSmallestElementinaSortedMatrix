#给一个2D matrix 寻找第 k 小的数字 matrix 从左至右递增，从上到下递增，但可以有重复元素，且不保证蛇形递增


#直接想法，将元素加入 一个 size 为 k 的 heap （priority queue）heap 的top即是第k小的树（最小的在最下面，所以用的是 max_heap, 即 默认的 PQ）

class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int row = matrix.size();
        int col= matrix[0].size();
        priority_queue <int> nums;
        for(int i= 0; i<row;i++){
            for(int j =0;j<col; j++){
                nums.emplace(matrix[i][j]);  
                if(nums.size()>k) nums.pop(); //当元素多于k时，新进来的元素会跟第k大的元素比较
            }
        }
        return nums.top();
    }
};

#时间复杂度 n（总元素个数）*lgN 
#空间 k

#用二分查找，每次找出upperbound 的个数，直至upperbound的数为k-1时 返回二分查找点（第k大）

Details
Start with half of the smallest and biggest of the matrix,
and then count how many numbers are smaller than or equal to it row by row;
K directly becomes the comparison determining which direction we will go in the next round, 
left part or the right part;
Keep the answer number within the range [l, r] in each round.
The time complexity will be O(nlognlogR) while n is the number of rows in the matrix 
and R is the difference between the smallest and the biggest number in the matrix.

Take [[1,4],[3,5]] 2 as an example. 
If we use the index range as the searching space, l=0, r=3, 
m=(0+3)/2=1 in the first round and then the numbers smaller than or equal to its number, 
matrix[m/size][m%size]=matrix[1/2][1%2]=matrix[0][1]=4, are 3 (1, 4 and 3 respectively) and then we will set r=m=1. 
Just now we have eliminated the potential answer number 3, 
whose index should be 2 matrix[2/2][2%2]=matrix[1][0]. 
All of these are because the index sequence is not linear to the matrix numbers whose order lies in two directions.
