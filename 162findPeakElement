#寻找一个数组的峰 
#要求 lgN 的时间复杂度
#所以用二分法

#想法是分mid的几种情况 峰； 谷； 上坡；下坡

class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        if(nums.empty()) return -1;
        if(nums.size()==1) return 0; 
        int start = 0;
        int end = nums.size()-1;
        while (start+1<end){
            int mid =(end-start)/2+start;
            if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid +1]) return mid;
            if(nums[mid]>nums[mid-1]&& nums[mid]<nums[mid +1]) start = mid;
            if(nums[mid]<nums[mid-1]&& nums[mid]>nums[mid +1]) end = mid;
            else {
                start = mid;
            }
        }
        
        //em。。。这题认为nums[-1] = nums[n] = -∞ 所以两端单调也得check一下
        if(start==0 && nums[start]>nums[start+1]) return 0;
        if(start!=0 && nums[start]>nums[start+1]&&nums[start]>nums[start-1]) return start;
        if(end==nums.size()-1 && nums[end]>nums[end-1]) return end;
        if(end!=nums.size()-1 && nums[end]>nums[end+1]&&nums[end]>nums[end-1]) return end;
        return -1;
    }
};

#time O(lgN)
#space O(1)
